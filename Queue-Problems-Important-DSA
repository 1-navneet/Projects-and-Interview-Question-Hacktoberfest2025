# ==================================================
# QUEUE PROBLEMS (EASY â†’ HARD)
# ==================================================

# ==================================================
# 01. Implement Queue Using Array
# ==================================================
"""
Implement a queue using Python list (array) with enqueue, dequeue, peek, and isEmpty functions.
"""
class QueueArray:
    def __init__(self):
        self.queue = []
    
    def enqueue(self, x):
        self.queue.append(x)
    
    def dequeue(self):
        if not self.is_empty():
            return self.queue.pop(0)
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.queue[0]
        return None
    
    def is_empty(self):
        return len(self.queue) == 0

# ==================================================
# 02. Implement Queue Using Stack
# ==================================================
"""
Implement a queue using two stacks.
"""
class QueueUsingStack:
    def __init__(self):
        self.s1 = []
        self.s2 = []
    
    def enqueue(self, x):
        self.s1.append(x)
    
    def dequeue(self):
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())
        return self.s2.pop() if self.s2 else None

# ==================================================
# 03. Circular Queue Implementation
# ==================================================
class CircularQueue:
    def __init__(self, k):
        self.q = [0]*k
        self.head = self.tail = -1
        self.size = k
    
    def enqueue(self, val):
        if (self.tail+1)%self.size == self.head:
            return False
        if self.head == -1:
            self.head = 0
        self.tail = (self.tail+1)%self.size
        self.q[self.tail] = val
        return True
    
    def dequeue(self):
        if self.head == -1:
            return False
        if self.head == self.tail:
            self.head = self.tail = -1
        else:
            self.head = (self.head+1)%self.size
        return True
    
    def Front(self):
        return self.q[self.head] if self.head != -1 else -1
    
    def Rear(self):
        return self.q[self.tail] if self.tail != -1 else -1

# ==================================================
# 04. First Non-Repeating Character in a Stream
# ==================================================
from collections import deque, Counter

def first_non_repeating(stream):
    count = Counter()
    queue = deque()
    result = []
    for ch in stream:
        count[ch] += 1
        queue.append(ch)
        while queue and count[queue[0]] > 1:
            queue.popleft()
        result.append(queue[0] if queue else '#')
    return result

# ==================================================
# 05. Sliding Window Maximum
# ==================================================
from collections import deque

def sliding_window_max(nums, k):
    q = deque()
    result = []
    for i, n in enumerate(nums):
        while q and nums[q[-1]] < n:
            q.pop()
        q.append(i)
        if q[0] == i-k:
            q.popleft()
        if i >= k-1:
            result.append(nums[q[0]])
    return result

# ==================================================
# 06. Generate Binary Numbers from 1 to N
# ==================================================
def generate_binary_numbers(n):
    result = []
    q = deque()
    q.append("1")
    for _ in range(n):
        s = q.popleft()
        result.append(s)
        q.append(s+"0")
        q.append(s+"1")
    return result

# ==================================================
# 07. Rotten Oranges / BFS in Grid
# ==================================================
def oranges_rotting(grid):
    from collections import deque
    rows, cols = len(grid), len(grid[0])
    q = deque()
    fresh = 0
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                q.append((r,c))
            elif grid[r][c] == 1:
                fresh += 1
    time = 0
    dirs = [(0,1),(1,0),(0,-1),(-1,0)]
    while q and fresh:
        for _ in range(len(q)):
            r,c = q.popleft()
            for dr, dc in dirs:
                nr, nc = r+dr, c+dc
                if 0<=nr<rows and 0<=nc<cols and grid[nr][nc]==1:
                    grid[nr][nc]=2
                    fresh -= 1
                    q.append((nr,nc))
        time += 1
    return time if fresh==0 else -1

# ==================================================
# 08. Design Hit Counter
# ==================================================
class HitCounter:
    def __init__(self):
        self.q = deque()
    
    def hit(self, timestamp):
        self.q.append(timestamp)
    
    def get_hits(self, timestamp):
        while self.q and self.q[0] <= timestamp-300:
            self.q.popleft()
        return len(self.q)

# ==================================================
# 09. LRU Cache (Queue + HashMap variation)
# ==================================================
class LRUCache:
    def __init__(self, capacity):
        from collections import OrderedDict
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key, value):
        self.cache[key] = value
        self.cache.move_to_end(key)
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

# ==================================================
# 10. Recent Counter / Sliding Window Requests
# ==================================================
class RecentCounter:
    def __init__(self):
        self.q = deque()
    
    def ping(self, t):
        self.q.append(t)
        while self.q[0] < t-3000:
            self.q.popleft()
        return len(self.q)

# ==================================================
# 11. Priority Queue / Min-Heap
# ==================================================
import heapq

def priority_queue_example(elements):
    heap = []
    for e in elements:
        heapq.heappush(heap, e)
    result = []
    while heap:
        result.append(heapq.heappop(heap))
    return result

# ==================================================
# 12. Task Scheduler / CPU Scheduler Problem
# ==================================================
from collections import Counter, deque

def task_scheduler(tasks, n):
    counts = list(Counter(tasks).values())
    counts.sort(reverse=True)
    time = 0
    q = deque()
    while counts or q:
        time += 1
        if counts:
            counts[0] -= 1
            if counts[0]==0:
                counts.pop(0)
        q = deque([x-1 for x in q if x-1>0])
        counts.sort(reverse=True)
    return time

# ==================================================
# 13. Maximum of All Subarrays of Size K
# ==================================================
def max_of_subarrays(nums, k):
    q = deque()
    result = []
    for i, num in enumerate(nums):
        while q and nums[q[-1]] < num:
            q.pop()
        q.append(i)
        if q[0] <= i-k:
            q.popleft()
        if i >= k-1:
            result.append(nums[q[0]])
    return result

# ==================================================
# 14. Design Snake Game
# ==================================================
class SnakeGame:
    def __init__(self, width, height, food):
        self.width = width
        self.height = height
        self.food = food
        self.snake = deque([(0,0)])
        self.positions = set([(0,0)])
    
    def move(self, direction):
        head = self.snake[-1]
        moves = {'U':(-1,0),'D':(1,0),'L':(0,-1),'R':(0,1)}
        new_head = (head[0]+moves[direction][0], head[1]+moves[direction][1])
        if (0<=new_head[0]<self.height and 0<=new_head[1]<self.width and new_head not in self.positions) or new_head==self.food[0]:
            self.snake.append(new_head)
            self.positions.add(new_head)
            if self.food and new_head == self.food[0]:
                self.food.pop(0)
            else:
                tail = self.snake.popleft()
                self.positions.remove(tail)
            return len(self.snake)-1
        return -1

# ==================================================
# 15. Shortest Path in Binary Matrix
# ==================================================
from collections import deque

def shortest_path_binary_matrix(grid):
    if grid[0][0]==1 or grid[-1][-1]==1: return -1
    n = len(grid)
    q = deque([(0,0,1)])
    dirs = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
    visited = set((0,0))
    while q:
        r,c,d = q.popleft()
        if r==n-1 and c==n-1:
            return d
        for dr,dc in dirs:
            nr,nc = r+dr,c+dc
            if 0<=nr<n and 0<=nc<n and grid[nr][nc]==0 and (nr,nc) not in visited:
                visited.add((nr,nc))
                q.append((nr,nc,d+1))
    return -1

# ==================================================
# End of Queue Problems
# ==================================================
