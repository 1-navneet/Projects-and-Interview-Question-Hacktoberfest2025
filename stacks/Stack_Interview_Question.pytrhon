# Stack Interview Questions ‚Äì Complete Python Solutions
# Description: A complete collection of important Stack problems with clear logic and implementation.


# 1Ô∏è‚É£ Implement Stack using Array
class StackArray:
    def __init__(self):
        self.stack = []
    def push(self, x):
        self.stack.append(x)
    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
    def peek(self):
        return self.stack[-1] if self.stack else None
    def is_empty(self):
        return len(self.stack) == 0


# 2Ô∏è‚É£ Implement Stack using Linked List
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class StackLinkedList:
    def __init__(self):
        self.top = None
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top
        self.top = new_node
    def pop(self):
        if self.top:
            popped = self.top.data
            self.top = self.top.next
            return popped
    def peek(self):
        return self.top.data if self.top else None


# 3Ô∏è‚É£ Reverse a String using Stack
def reverse_string(s):
    stack = []
    for ch in s:
        stack.append(ch)
    return ''.join(stack.pop() for _ in range(len(stack)))


# 4Ô∏è‚É£ Check for Balanced Parentheses
def is_balanced(expr):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for ch in expr:
        if ch in mapping.values():
            stack.append(ch)
        elif ch in mapping:
            if not stack or stack.pop() != mapping[ch]:
                return False
    return not stack


# 5Ô∏è‚É£ Evaluate Postfix Expression
def evaluate_postfix(expression):
    stack = []
    for ch in expression:
        if ch.isdigit():
            stack.append(int(ch))
        else:
            b, a = stack.pop(), stack.pop()
            if ch == '+': stack.append(a + b)
            elif ch == '-': stack.append(a - b)
            elif ch == '*': stack.append(a * b)
            elif ch == '/': stack.append(a // b)
    return stack[0]


# 6Ô∏è‚É£ Infix to Postfix Conversion
def infix_to_postfix(expr):
    prec = {'+':1, '-':1, '*':2, '/':2, '^':3}
    stack, result = [], []
    for ch in expr:
        if ch.isalnum():
            result.append(ch)
        elif ch == '(':
            stack.append(ch)
        elif ch == ')':
            while stack and stack[-1] != '(':
                result.append(stack.pop())
            stack.pop()
        else:
            while stack and prec.get(ch, 0) <= prec.get(stack[-1], 0):
                result.append(stack.pop())
            stack.append(ch)
    while stack:
        result.append(stack.pop())
    return ''.join(result)


# 7Ô∏è‚É£ Next Greater Element
def next_greater(arr):
    res = [-1]*len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[stack[-1]] < arr[i]:
            res[stack.pop()] = arr[i]
        stack.append(i)
    return res


# 8Ô∏è‚É£ Next Smaller Element
def next_smaller(arr):
    res = [-1]*len(arr)
    stack = []
    for i in range(len(arr)):
        while stack and arr[stack[-1]] > arr[i]:
            res[stack.pop()] = arr[i]
        stack.append(i)
    return res


# 9Ô∏è‚É£ Stock Span Problem
def stock_span(prices):
    stack = []
    span = [0]*len(prices)
    for i in range(len(prices)):
        while stack and prices[i] >= prices[stack[-1]]:
            stack.pop()
        span[i] = i+1 if not stack else i-stack[-1]
        stack.append(i)
    return span


# üîü Minimum Element in Stack (O(1) extra space)
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []
    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)
    def pop(self):
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()
    def get_min(self):
        return self.min_stack[-1]


# 1Ô∏è‚É£1Ô∏è‚É£ Sort a Stack using Recursion
def sort_stack(stack):
    if stack:
        temp = stack.pop()
        sort_stack(stack)
        insert_sorted(stack, temp)
def insert_sorted(stack, element):
    if not stack or element > stack[-1]:
        stack.append(element)
    else:
        temp = stack.pop()
        insert_sorted(stack, element)
        stack.append(temp)


# 1Ô∏è‚É£2Ô∏è‚É£ Reverse a Stack using Recursion
def reverse_stack(stack):
    if stack:
        temp = stack.pop()
        reverse_stack(stack)
        insert_bottom(stack, temp)
def insert_bottom(stack, item):
    if not stack:
        stack.append(item)
    else:
        temp = stack.pop()
        insert_bottom(stack, item)
        stack.append(temp)


# 1Ô∏è‚É£3Ô∏è‚É£ Celebrity Problem
def celebrity(matrix, n):
    stack = [i for i in range(n)]
    while len(stack) > 1:
        a, b = stack.pop(), stack.pop()
        if matrix[a][b] == 1:
            stack.append(b)
        else:
            stack.append(a)
    if not stack:
        return -1
    c = stack.pop()
    for i in range(n):
        if i != c and (matrix[c][i] == 1 or matrix[i][c] == 0):
            return -1
    return c


# 1Ô∏è‚É£4Ô∏è‚É£ Largest Rectangle in Histogram
def largest_rectangle(heights):
    stack, max_area = [], 0
    heights.append(0)
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area


# 1Ô∏è‚É£5Ô∏è‚É£ Trapping Rain Water
def trap_rain_water(height):
    left, right = 0, len(height)-1
    left_max = right_max = water = 0
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    return water


# 1Ô∏è‚É£6Ô∏è‚É£ Remove Consecutive Duplicates
def remove_consecutive_duplicates(s):
    stack = []
    for ch in s:
        if stack and stack[-1] == ch:
            stack.pop()
        else:
            stack.append(ch)
    return ''.join(stack)


# 1Ô∏è‚É£7Ô∏è‚É£ Valid Parenthesis String (with '*')
def check_valid_parenthesis(s):
    left_min = left_max = 0
    for ch in s:
        if ch == '(':
            left_min += 1; left_max += 1
        elif ch == ')':
            left_min -= 1; left_max -= 1
        else:
            left_min -= 1; left_max += 1
        if left_max < 0:
            return False
        left_min = max(left_min, 0)
    return left_min == 0


# 1Ô∏è‚É£8Ô∏è‚É£ Decode String (e.g. "3[a2[b]]" ‚Üí "abbabbabb")
def decode_string(s):
    stack, curr_str, num = [], "", 0
    for ch in s:
        if ch.isdigit():
            num = num*10 + int(ch)
        elif ch == '[':
            stack.append((curr_str, num))
            curr_str, num = "", 0
        elif ch == ']':
            prev_str, n = stack.pop()
            curr_str = prev_str + n*curr_str
        else:
            curr_str += ch
    return curr_str


# 1Ô∏è‚É£9Ô∏è‚É£ Nearest Greater to Left / Right
def nearest_greater_left(arr):
    res, stack = [], []
    for x in arr:
        while stack and stack[-1] <= x:
            stack.pop()
        res.append(stack[-1] if stack else -1)
        stack.append(x)
    return res


def nearest_greater_right(arr):
    res, stack = [-1]*len(arr), []
    for i in range(len(arr)-1, -1, -1):
        while stack and stack[-1] <= arr[i]:
            stack.pop()
        res[i] = stack[-1] if stack else -1
        stack.append(arr[i])
    return res


# 2Ô∏è‚É£0Ô∏è‚É£ Expression Evaluation (Infix)
def evaluate_infix(expr):
    def precedence(op):
        if op in ('+', '-'): return 1
        if op in ('*', '/'): return 2
        return 0

    def apply(a, b, op):
        if op == '+': return a + b
        if op == '-': return a - b
        if op == '*': return a * b
        if op == '/': return int(a / b)

    nums, ops = [], []
    i = 0
    while i < len(expr):
        if expr[i] == ' ':
            i += 1
            continue
        if expr[i] == '(':
            ops.append(expr[i])
        elif expr[i].isdigit():
            val = 0
            while i < len(expr) and expr[i].isdigit():
                val = val*10 + int(expr[i])
                i += 1
            nums.append(val)
            i -= 1
        elif expr[i] == ')':
            while ops and ops[-1] != '(':
                nums.append(apply(nums.pop(-2), nums.pop(), ops.pop()))
            ops.pop()
        else:
            while ops and precedence(ops[-1]) >= precedence(expr[i]):
                nums.append(apply(nums.pop(-2), nums.pop(), ops.pop()))
            ops.append(expr[i])
        i += 1
    while ops:
        nums.append(apply(nums.pop(-2), nums.pop(), ops.pop()))
    return nums[-1]
